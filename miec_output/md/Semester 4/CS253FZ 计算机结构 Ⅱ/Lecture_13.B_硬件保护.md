# Lecture 13.B 硬件保护

## UART

有一个 8253 UART 的芯片，充当 CPU 跟硬件之间 IO 的中介。简单地说就是，如果硬件想给 CPU 发送数据，就会先传给 8253 UART 的缓冲区，然后 CPU 需要的时候再去缓冲区检索；CPU 发数据给硬件，也是先传给 UART 缓冲区，然后这个芯片再传给硬件。

![UART](https://s2.loli.net/2023/07/03/XGPaghuOMnIvH8o.png)

## IO 的方法

### 同步的

![同步IO](https://s2.loli.net/2023/07/03/rutsxWoZv5EJRAw.png)

就是 CPU 在 IO 期间一直在等待硬件完成操作，不干别的，就这么闲着。所以比较浪费。

### 异步的

![异步IO](https://s2.loli.net/2023/07/03/Efqt9hLKRyxXVYZ.png)

就是 IO 发起之后，CPU 直接回去执行接下来的指令。但是如果接下来的指令必须是 IO 完成后才能执行的，要等待硬件发回来一个信号。

由于 CPU 一次只能处理一个设备，所以也有可能导致效率问题。

改进方式是，让操作系统维护一个设备状态表（device status table），每个设备可能具有一个请求队列。通过中断等方式进行进程切换。

## 硬件保护

比如：

*   两个进程之间不能相互影响。不能一个硬件被进程 A 一直占用着而轮不到进程 B。
*   假如硬件遇到故障，发送中断信号给 CPU，CPU 应当掐掉当前使用这个硬件的进程。

### 运行模式保护

操作系统至少提供两种运行模式，user mode 和 supervisor mode。其中，user mode 可以执行的指令只是一部分，并不完整。

对于那些可能产生危险的指令，只能从 supervisor mode 执行。比如，IO 指令，就属于这种，只能通过操作系统的 supervisor mode 执行的。

user mode 的程序不能自己切换到 supervisor mode，必须使用系统调用，向操作系统请求权限。然后操作系统就会检查一下这个程序想要执行的指令是否可以执行。如果可以，就开放权限，不行就拒绝。

![运行模式](https://s2.loli.net/2023/07/03/F9BawHxbqGcZkU2.png)

### 内存保护

比如说，中断向量表，这里的内存特别特别关键，不能被用户程序随意更改！

使用 base+limit 寄存器的方式，可以限定一个程序可以访问的内存区间。

### CPU 保护

8086 里面 0 号中断（计时器），差不多每隔 18ms 就进行一次，产生一次上下文切换。切换之后就可以检查一下，有没有哪一个程序出问题了（比如，运行了好久，那就考虑掐掉）。

在一些高级的系统当中，可能有一个单独的时钟系统用来做这个事情。
