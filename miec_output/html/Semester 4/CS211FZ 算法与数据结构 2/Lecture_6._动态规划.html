<bound method Tag.prettify of <article class="md-content__inner md-typeset">
<h1 id="lecture-6">Lecture 6. 动态规划</h1>
<blockquote>
<p>为贪心而设的门紧锁着，为爆搜而开的洞敞开着，一个声音高叫着：用动规吧，给你满分！</p>
</blockquote>
<h2 id="_1">动规基本原理</h2>
<h3 id="vs">分治 vs 动规</h3>
<p>分治是把一个大问题，分解成若干个 disjoint 互不相交的子问题，然后递归求解子问题，再把子问题合并成原问题的解。</p>
<p>对于子问题重叠（overlap）的情况，即子问题和子问题中间有共同的子子问题。这种情况下如果使用分治，就会重复计算；</p>
<p>动态规划，对于每一个子子问题，只求解一次，然后将结果保存到一个表格里。再次需要这个子子问题的时候，查表即可，无需重复计算（<em>记忆化 memorization</em>）。</p>
<p>通常动态规划用来求解 <em>最优化问题（optimization problem）</em>，就是说找到一堆可行解当中的最优解。实际上最优解可能不仅有一个，动态规划方法找到一个即可。</p>
<h3 id="_2">动规的步骤</h3>
<ol>
<li>刻画（characterize）一个最优解的结构特征</li>
<li>递归地定义最优解的值</li>
<li>计算出最优解的值（通常是自底向上）</li>
<li>（可选）利用前三步计算的信息，把最优解的方案构造出来</li>
</ol>
<h3 id="_3">什么时候用动规</h3>
<p>适合使用动规求解的最优化问题，应当具备两个基本性质：<strong>最优子结构、重叠子问题</strong>。</p>
<h3 id="_4">动规的时间复杂度</h3>
<p>对于不同的问题，时间复杂度不尽相同，取决于两个因素</p>
<ol>
<li>有多少个子问题</li>
<li>对于每个子问题，要考察多少个不同选择</li>
</ol>
<h4 id="optimal-sub-structure">最优子结构 optimal sub-structure</h4>
<p>一个问题的最优解，包含其子问题的最优解，这就是「最优子结构」</p>
<p>如果某个问题具有最优子结构的性质，那么他可能就可以用动规求解。</p>
<p>动规的第一步：刻画最优子结构。那么如何发掘最优子结构？</p>
<ol>
<li>需要证明：问题的最优解的第一个组成部分是，做出一个选择。这个选择会产生一个或多个子问题，比如背包问题。</li>
<li>假定在第一步的选择当中，已经知道了哪种选择可以得到最优解（并不关心该如何选，只是假定能知道哪个是）</li>
<li>做出选择后，确定出这个选择会产生哪些子问题，以及如何最好的刻画子问题空间</li>
<li>利用 cut-and-paste 方法证明，这个问题的最优解当中子问题的解，对于子问题而言，也是最优解。<ul>
<li>可以用反证法证明。假设最优解当中子问题的解不是最优解</li>
<li>然后把子问题的解「剪贴粘贴」改成最优解</li>
<li>然后发现原问题的解变地更好了，形成矛盾</li>
</ul>
</li>
</ol>
<p>对于不同的问题，可能还会有两点不同：</p>
<ol>
<li>原问题的最优解，涉及到的最优子结构的个数</li>
<li>确定最优解包含哪些子问题的时候，可以选择的个数</li>
</ol>
<p>一般在代码实现当中，会使用自底向上的方法，来利用最优子结构。说白了就是，得到子问题的最优解，从而得到原问题的最优解。原问题的解的值，一般就是子问题的解的值，加上选择所产生的值。</p>
<h4 id="overlapping-sub-problem">重叠子问题 overlapping sub-problem</h4>
<p>就是说一个问题的递归算法，总是在反复求解某些相同的问题，而没有不断生成新的子问题。也就是说子问题的空间应当是足够小的，最好是多项式等级的。这就叫「重叠子问题」性质。</p>
<p>于是可以用记忆化（查表）的方式快速得到某个已经计算过的问题的解。</p>
<h2 id="_5">例：最长公共子序列问题</h2>
<p>用四个步骤来算出最长公共子序列。</p>
<h3 id="lcs">第一步：刻画 LCS</h3>
<p>定义：</p>
<ul>
<li>长度为 $m$ 的字符串 $X = \langle x_1, x_2, \cdots, x_m \rangle$</li>
<li>$X_i = \langle x_1, x_2, \cdots, x_i \rangle$ 是 $X$ 的第 $i$ 个前缀</li>
<li>长度为 $n$ 的字符串 $Y$ 及其 $n$ 个前缀同理</li>
</ul>
<p>则显然满足以下三点性质（详细证明在书上）：</p>
<ol>
<li>若 $x_m = y_n$ 即 $X$ 与 $Y$ 的最后一个字符相等，则 $z_k = x_m = y_n$ 且 $Z_{k-1}$ 是 $X_{m-1}$ 和 $Y_{n-1}$ 的一个 LCS，减小原问题的规模</li>
<li>若 $x_m \ne y_n$ 即 $X$ 与 $Y$ 的最后一个字符不相等，那么 $z_k \ne x_m$ 就意味着 $Z$ 是 $X_{m-1}$ 和 $Y$ 的一个 LCS，即假如 LCS 的最后一个字符与 $X$ 的最后一个字符不同，就可以当作 $X_{m-1}$ 和 $Y$ 的 LCS 问题，减小规模</li>
<li>若 $x_m \ne y_n$ 即 $X$ 与 $Y$ 的最后一个字符不相等，那么 $z_k \ne y_n$ 就意味着 $Z$ 是 $X$ 和 $Y_{n-1}$ 的一个 LCS，即假如 LCS 的最后一个字符与 $Y$ 的最后一个字符不同，就可以当作 $X$ 和 $Y_{n-1}$ 的 LCS 问题，减小规模</li>
</ol>
<p>简单总结来说就是：两个字符串的 LCS 会包含两个字符串的前缀的 LCS，因此 LCS 问题具有最优子结构性质。</p>
<h3 id="_6">第二步：递归解</h3>
<p>根据上述性质，求解 LCS 问题的时候，要分两类情况讨论</p>
<ul>
<li>一个情况是 $x_m = y_n$，直接转化为 $X_{m-1}$ 和 $Y_{n-1}$ 的 LCS 问题</li>
<li>另一情况是 $x_m \ne y_n$，则求 $X_{m-1}$ 与 $Y$ 的一个 LCS，再求 $X$ 与 $Y_{n-1}$ 的一个 LCS，取两个当中长的那个</li>
</ul>
<p>由于这样分类讨论可以覆盖所有的可能情况，所以必然有一个子问题的最优解，出现在原问题的最优解（$X$ 与 $Y$ 的 LCS）当中。</p>
<p>然后 $X_{m-1}$ 与 $Y$ 的子问题当中可能包含 $X_{m-1}$ 与 $Y_{n-1}$ 的 LCS 问题，这就产生好多重叠。</p>
<p>最后列出状态转移方程。令 $c[i,j]$ 表示 $X_i$ 与 $Y_j$ 的 LCS 的长度：</p>
<p>$$c[i,j] = \begin{cases}0 &amp; i=0\text{ 或 }j=0 \\ c[i-1,j-1]+1 &amp; i,j&gt;0\text{ 且 }x_i=y_j \\ \max(c[i,j-1],c[i-1,j]) &amp; i,j&gt;0\text{ 且 }x_i \ne y_j\end{cases}$$</p>
<h3 id="lcs_1">第三步：算出 LCS 的长度是多少</h3>
<p>所有子问题的规模总和，即 $c[i,j]$ 的大小，是 $\Theta(mn)$，于是可以自底向上递归计算。</p>
<p>由于每一个 $c[i,j]$ 都是 $\Theta(1)$ 计算的，所以这个函数的时间复杂度也是 $\Theta(nm)$。</p>
<p><img alt="" src="https://s2.loli.net/2023/07/04/omXK7z6SGV4x9BD.png"/></p>
<h3 id="lcs_2">第四步：构造出一个 LCS</h3>
<p>在计算 $c[i,j]$ 的同时，维护了一个 $b$，$b[i,j]$ 表示的是计算 $c[i,j]$ 的时候，选择了哪一个子问题的最优解，取值只有三种：左、上、左上。</p>
<p>然后根据 $b$ 的信息，把所有 ↖ 箭头对应的 $i,j$ 拿出来（$x_i=y_j$ 一定满足），就可以构造出来一个 LCS，如图所示。</p>
<p><img alt="" src="https://s2.loli.net/2023/07/04/FqnpbSgkVxyvf9w.png"/></p>
<p>对应到代码，就是从右下角开始一直根据箭头方向走，时间复杂度 $O(m+n)$。</p>
<p><img alt="" src="https://s2.loli.net/2023/07/04/AjrIOfZMvsEx8Cc.png"/></p>
<h3 id="_7">算法的改进</h3>
<p>其实 $b$ 是不需要的，因为 $b[i,j]$ 可以根据 $c$ 算出来，所以 $b$ 数组可以省略。</p>
<p>但是由于 $c$ 数组是必须的，所以空间复杂度仍然是 $\Theta(mn)$ 没啥变化。</p>
<p>然而如果不需要构造 LCS 只想知道长度的话，可以利用滚动数组之类的思想，减少 $c$ 的空间使用。</p>
</article>>