<bound method Tag.prettify of <article class="md-content__inner md-typeset">
<h1 id="lecture-14-integration-testing">Lecture 14. Integration Testing 集成测试</h1>
<p>单元测试做完之后，就是集成测试。</p>
<p>单元测试是测试每一个独立的组件。</p>
<p>集成测试的目的是，确保程序当中的每一个组件都能结合得很好。</p>
<p>然而其实集成测试做的不多，而且关于集成测试的工具也比较少。</p>
<h3 id="_1">驱动模块桩模块</h3>
<h3 id="_2">驱动模块</h3>
<p>驱动和桩模块，是软件的临时成分。</p>
<p>驱动模块的目的很单纯，就是为了访问类库的属性和方法，来检测类库的功能是否正确。</p>
<p>驱动模块是用来模拟被测试模块的上一级模块，相当于被测模块的主程序，调用被测模块。</p>
<p>~~然后走神了~~</p>
<h3 id="_3">桩模块</h3>
<p>~~有些走神~~</p>
<p>专供测试用的「假」模块（替身）称为被测模块的桩模块。</p>
<h3 id="_4">关系</h3>
<p>驱动模块 调用 软件 调用 桩模块</p>
<p>事实上驱动模块更好写，因为驱动模块只需要考虑怎么调用，而桩模块需要考虑如何实现。打个比方，桩模块就是平衡树的各个功能，非常长，而驱动模块就是主函数，只有几行调用</p>
<h2 id="_5">集成测试常用方法</h2>
<p>对于增量集成：</p>
<ul>
<li>自顶向下（top-down）集成</li>
<li>自底向上（bottom-up）集成</li>
<li>三明治（sandwich）集成，说白了就是前两种合在一起。</li>
</ul>
<p>此外还有不增量集成。</p>
<p>增量集成大概就说循序渐进的意思，而不增量的比较粗暴，全都直接测了。</p>
<h3 id="_6">自顶向下</h3>
<p>差不多就是，先测第一层，没问题就延申到前两层一起测，再没问题就前三层一起测，以此类推……</p>
<p>好处就是，可以比较早期的了解到程序的基本结构框架（虽然细节部分可能还没设计好）</p>
<p>坏处就是，要写好多桩模块。而桩模块可能不是那么好写。而且如果有新的下层模块加入，上层模块可能还要重新测，比如可能上层对下层的调用会隐含着 bug。</p>
<h3 id="_7">自底向上</h3>
<p>跟自顶向下相反了。先测最底层，没问题就网上扩展一层，再没问题就继续，以此类推……</p>
<p>好处就是，可以看到各个功能模块的功能。而且桩模块不用来回写了！但是驱动模块每一层都要换一下。同时</p>
<p>缺点就是，知道了细节和底层，但是可能不太了解整体。而且用户通常是最顶层的调用者，所以最后阶段才能以用户的视角进行测试。</p>
<h3 id="_8">三明治</h3>
<p>实践中，大部分软件开发都是三明治测试。</p>
<p>有点类似双线程双向搜索的感觉。</p>
<p>具有自顶向下和自底向上的两种好处。但是中间层怎么选择比较困难。</p>
<h3 id="_9">小结</h3>
<p>需要设计桩模块和驱动模块。需要考虑到~~考虑到啥来着？~~</p>
<h2 id="_10">端对端</h2>
<p>与敏捷测试结合使用。</p>
<p>提了一嘴，好像不太重要？</p>
</article>>